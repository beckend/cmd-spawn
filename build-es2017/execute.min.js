const child_process_1=require("child_process");const Bluebird=require("bluebird");const cSpawn=require("cross-spawn");
exports.execute=({cmd,cmdArgs,spawnOpts,crossSpawn:useCrossSpawn,shouldBuffer})=>{let promise;let cp=undefined;if(shouldBuffer){promise=new Bluebird((resolve,reject)=>{let stderrBuff=new Buffer("");let stdoutBuff=new Buffer("");cp=useCrossSpawn?cSpawn(cmd,cmdArgs,spawnOpts):child_process_1.spawn(cmd,cmdArgs,spawnOpts);if(cp.stdout)cp.stdout.on("data",(data)=>{stdoutBuff=Buffer.concat([stdoutBuff,data])});if(cp.stderr)cp.stderr.on("data",(data)=>{stderrBuff=Buffer.concat([stderrBuff,data])});cp.once("error",
reject);cp.once("close",(code,signal)=>{const stdout=stdoutBuff.toString();const stderr=stderrBuff.toString();if(code===0)resolve({stdout,stderr});else reject(Object.assign(new Error(`Failed to execute "${cmd}", exit code of #${code}`),{code:"ECMDERR",stderr,stdout,details:stderr,status:code,signal}))})});promise.cp=cp;return promise}else{promise=new Bluebird((resolve,reject)=>{cp=useCrossSpawn?cSpawn(cmd,cmdArgs,spawnOpts):child_process_1.spawn(cmd,cmdArgs,spawnOpts);cp.once("error",reject);cp.once("close",
(code)=>{if(code===0)resolve();else reject(`child process exited with code ${code}`)})});promise.cp=cp;return promise}};